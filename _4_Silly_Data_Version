Last week I focused on how to store the outputs while using FOR loops to path, but it occurred to me, Python is so versatile, it allows things a relational database would not. And so dear readers, a new question is born, How would Python handle bad data?

import csv
silly_dictionary = {"tuple9":(2,1,1,'Apple',(1,0,0)),"tuple10":(0,1,1,'Banana',(0,1,1)),"tuple11":(2,0,1,'Cantaloupe',(1,1,0))}
silly2_dictionary = {"tuple9":(2,1,1,'Apple',(1,0,0)),"tuple10":(0,1,1,'Banana',(0,1,1)),"tuple12":('',0,1,'Durian',(1,1,0))}

Just another weekday. Dictionaries are collections of anything: Integers, Strings, Tuples, Tuples within Tuples, anything that wont throw an error during run time is welcome. And even though I mentioned Python IF/ELIF was the best translation for SQL CASE syntax, How does it compare to FOR loops?

def segmenting_via_if (tuple) :
  if tuple[0] == 1 :
    if tuple[1] == 1 :
      if tuple[2] == 1 : return (7)
      return (6)
    elif tuple[2] == 1 : return (5)
    return (1)
  elif tuple[1] == 1 :
    if tuple[2] == 1 : return (4)
    return (2)
  elif tuple[2] == 1 : return (3)
  return (0)

def segmenting_via_for (tuple) :
  for keys in range (tuple[0]) :
    for keys in range (tuple[1]) :
      for keys in range (tuple[2]) : return (7)
      return (6)
    for keys in range (tuple[2]) : return (5)
    return (1)
  for keys in range (tuple[1]) :
    for keys in range (tuple[2]) : return (4)
    return (2)
  for keys in range (tuple[2]) : return (3)
  return (0)

Previously, I briefly mentioned WHILE directly compares the value to equaling 1 (like IF/ELIF), but FOR compares integers to not equaling zero. This means the FOR method will throw errors if anything non-Integer is at that location, but IF/ELIF will not. Also because of this, the rows get categorized differently because that's how the pathing works (443 vs 745), but for now we have to duplicate and update the wrapper-version so the IDE knows when to call which and labels them for us appropriately.

# old way with IF
def wrapper_for_pretty_outputs_via_if (dictionary):
  for keys,values in dictionary.items():
    segment_value = segmenting_via_if(values)
    if segment_value == 0:
      pass
    else:
      print("Via IF "+keys+" :",values,":",segment_value)

print(type(wrapper_for_pretty_outputs_via_if(silly_dictionary)))

# old way with FOR
def wrapper_for_pretty_outputs_via_for (dictionary):
  for keys,values in dictionary.items():
    segment_value = segmenting_via_for(values)
    if segment_value == 0:
      pass
    else:
      print("Via FOR "+keys+" :",values,":",segment_value)

print(type(wrapper_for_pretty_outputs_via_for(silly_dictionary)))

The above wrappers really outline how this prints each line as they are processed because I called for the data type of the wrapper outputs and got "NoneType" after every row output is printed. Last, but not least, I did not have a great method of saving outputs when I started translating to Python. How does the new saving method work with IF and silly data?

# New, safer way with IF disposes of 'extra data'
def create_sorted_dictionary(dictionary):
  print_dictionary = {}
  for keys,values in dictionary.items():
    segment_category = segmenting_via_if(values) # 1 line update required.
#    print(print_dictionary.values())
    if segment_category != 0:
      print_dictionary[keys] = (values[0], values[1], values[2], segment_category)
  return (print_dictionary)

saving_sorted_dictionary = create_sorted_dictionary(silly2_dictionary)
print(saving_sorted_dictionary)
print(type(saving_sorted_dictionary))

The new method is pretty neat. It was exceptionally easy to change which sorting method was used because of how modular it is (not possible with the old version). Also, the new method does not carry unnecessary data forward, which makes it more precise, almost like a SQL view. Here are the IDE and CSV outputs to confirm:

443 vs 745 and you can see how much less data is carried forward by the new method.

Simple CSV, but that is a good thing.I would call the new method good enough for now, because IF is stable, accurate, and the outputs can be analyzed by other tools, which is the real goal. You wont get pretty graphs or pretty dashboards in Python without a multitude of import statements. Python is extremely versatile and good for many things, but just the fact Python will store NULL values in a field shows it may be too versatile to be a competitor to relational databases.

csv_file = 'silly_dictionary2csv.csv'
with open(csv_file, 'w', newline='') as file:
  writer = csv.writer(file)
  writer.writerow(['Key', 'Value'])
  for key, value in saving_sorted_dictionary.items():
    writer.writerow([key, value])

print(f"Dictionary saved to {csv_file}")
